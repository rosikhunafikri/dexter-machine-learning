class MCPNetwork:
    def __init__(self, n_inputs, n_hidden, w=None, threshold=0):
        # Set weights of output neuron (not of hidden neurons)
        if w is None:
            self.w = np.zeros(n_hidden)
        else:
            assert len(self.w) == n_hidden, "Error, number of inputs must be the same as the number of hidden units."
            self.w = w
        # Set threshold of output neuron (not of hidden neurons)
        self.threshold = threshold

        # <START Your code here>
        # Add the hidden units
        # Create a list of hidden MCP units according to n_inputs and n_hidden.
        self.hidden_units = [MCPNeuron(n_inputs) for _ in range(n_hidden)]
        # <END Your code here>
        return

    def forward(self, x):
        """
        :param x: The input values
        :return: The output in the interval [-1,1]
        """
        # <START Your code here>
        hidden_out = [h.forward(x) for h in self.hidden_units]
        weighted_sum = inner_prod(self.w, hidden_out, use_numpy=True) - self.threshold
        y = np.sign(weighted_sum)
        if y == 0:
            y = 1
        return y
        # <END Your code here>

    # Implement a function to randomize the weights and the threshold
    def set_random_params(self):
        # <START Your code here>
        self.w = np.random.random(self.w.shape)
        self.w *= 2
        self.w -= 1
        self.threshold = np.random.random(1)[0]
        self.threshold *= 2
        self.threshold -= 1
        for h in self.hidden_units:
            h.set_random_params()
        # <END Your code here>
        return

    # Implement a function to check whether the MCP neuron represents a specific Boolean Function
    def is_bf(self, bf):
        # <START Your code here>
        fail = False
        for x in bf.keys():
            y = bf[x]
            pred = self.forward(x)
            if y != pred:
                fail = True
                break
        # <END Your code here>
        return not fail